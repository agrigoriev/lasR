% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/algorithm.R
\name{rasterize}
\alias{rasterize}
\title{Rasterize a point cloud}
\usage{
rasterize(
  res,
  operators = "max",
  filter = "",
  ofile = tempfile(fileext = ".tif")
)
}
\arguments{
\item{res}{numeric. The resolution of the raster.}

\item{operators}{Can be a character vector. "min", "max" and "count" are accepted. Can also
rasterize a triangulation if the input is a LASRalgorithm for triangulation (see examples).
Can also be a user-defined expression (see example and details).}

\item{filter}{the 'filter' argument allows filtering of the point-cloud to work with points of
interest. The available filters are those from LASlib and can be found by running `print_filters()`.
For a given algorithm when a filter is applied, only the points that meet the criteria are processes.
The most common strings are "-keep_first", "-keep_class 2", "drop_z_below 2". For more details see
\link{filters}.}

\item{ofile}{character. Full outputs are always stored on disk. If \code{ofile = ""}
then the algorithm will not store the result on disk and will return nothing. It will however
hold partial output results temporarily in memory. This is useful for algorithm that are only
intermediate stage.}
}
\description{
Rasterize a point cloud using different approaches. This algorithm does not modify the point cloud.
It produces a derived product in raster format.
}
\details{
If \code{operators} is a user-defined expression, the function must return either a vector of numbers
or a list with atomic numbers. To assign a band name to the raster the vector or the list must be named.
These are valid operators:

\if{html}{\out{<div class="sourceCode">}}\preformatted{f = function(x) \{ return(mean(x)) \}
g = function(x,y) \{ return(c(avg = mean(x), med = median(y))) \}
h = function(x) \{ return(list(a = mean(x), b = median(x))) \}
rasterize(10, f(Intensity))
rasterize(10, g(Z, Intensity))
rasterize(10, h(Z))
}\if{html}{\out{</div>}}
}
\examples{
f <- system.file("extdata", "Topography.las", package="lasR")
read <- reader(f)
tri  <- triangulate(filter = "-keep_class 2")
dtm  <- rasterize(1, tri) # input is a triangulation algorithm
avgi <- rasterize(10, mean(Intensity)) # input is a user expression
chm  <- rasterize(2, "max") # input is a character vector
pipeline <- read + tri + dtm + avgi + chm
ans <- processor(pipeline)
ans[[1]]
ans[[2]]
ans[[3]]
}
